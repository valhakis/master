<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<title>~/master/node/master/static/public/sample/valhakis/src/valhakis.c.html</title>
<meta name="Generator" content="Vim/8.0">
<meta name="plugin-version" content="vim7.4_v2">
<meta name="syntax" content="c">
<meta name="settings" content="use_css,no_foldcolumn,expand_tabs,prevent_copy=">
<meta name="colorscheme" content="antares">
<style type="text/css">
<!--
pre { font-family: monospace; color: #b2b2b2; background-color: #080808; }
body { font-family: monospace; color: #b2b2b2; background-color: #080808; }
* { font-size: 1em; }
.cType { color: #87d7ff; }
.String { color: #00af5f; }
.cFormat { color: #afaf5f; }
.cNumber { color: #ff875f; }
.cConstant { color: #00af5f; font-weight: bold; }
.cStorageClass { color: #ffd75f; }
.cSpecial { color: #afaf5f; font-weight: bold; }
.cInclude { color: #d75f5f; }
.cConditional { color: #87d7ff; }
.cDefine { color: #d75f5f; }
.Comment { color: #ff6060; }
.Statement { color: #ffd75f; }
.cOperator { color: #00d7d7; }
-->
</style>

<script type='text/javascript'>
<!--

-->
</script>
</head>
<body>
<pre id='vimCodeElement'>
<span class="cInclude">#include </span><span class="String">&lt;stdio.h&gt;</span>
<span class="cInclude">#include </span><span class="String">&lt;stdbool.h&gt;</span>
<span class="cInclude">#include </span><span class="String">&lt;stdlib.h&gt;</span>
<span class="cInclude">#include </span><span class="String">&lt;stdarg.h&gt;</span>
<span class="cInclude">#include </span><span class="String">&lt;glad/glad.h&gt;</span>
<span class="cInclude">#include </span><span class="String">&lt;GLFW/glfw3.h&gt;</span>

<span class="cType">void</span> ValLog(<span class="cStorageClass">const</span> <span class="cType">char</span> *format, ...);
<span class="cType">void</span> ValErr(<span class="cStorageClass">const</span> <span class="cType">char</span> *format, ...);
<span class="cType">char</span> *ValReadSource(<span class="cStorageClass">const</span> <span class="cType">char</span> *file);
<span class="cType">int</span> ValCreateShader(GLenum type, <span class="cStorageClass">const</span> <span class="cType">char</span> *file);
<span class="cType">int</span> ValCreateProgram(<span class="cType">int</span> vshader, <span class="cType">int</span> fshader);

<span class="cDefine">#define KNRM  </span><span class="String">&quot;</span><span class="cSpecial">\x1B</span><span class="String">[0m&quot;</span>
<span class="cDefine">#define KRED  </span><span class="String">&quot;</span><span class="cSpecial">\x1B</span><span class="String">[31m&quot;</span>
<span class="cDefine">#define KGRN  </span><span class="String">&quot;</span><span class="cSpecial">\x1B</span><span class="String">[32m&quot;</span>
<span class="cDefine">#define KYEL  </span><span class="String">&quot;</span><span class="cSpecial">\x1B</span><span class="String">[33m&quot;</span>
<span class="cDefine">#define KBLU  </span><span class="String">&quot;</span><span class="cSpecial">\x1B</span><span class="String">[34m&quot;</span>
<span class="cDefine">#define KMAG  </span><span class="String">&quot;</span><span class="cSpecial">\x1B</span><span class="String">[35m&quot;</span>
<span class="cDefine">#define KCYN  </span><span class="String">&quot;</span><span class="cSpecial">\x1B</span><span class="String">[36m&quot;</span>
<span class="cDefine">#define KWHT  </span><span class="String">&quot;</span><span class="cSpecial">\x1B</span><span class="String">[37m&quot;</span>

<span class="cType">void</span> ValErr(<span class="cStorageClass">const</span> <span class="cType">char</span> *format, ...)
{
  <span class="cType">va_list</span> args;
  fprintf(<span class="cConstant">stderr</span>, KRED);
  fprintf(<span class="cConstant">stderr</span>, <span class="String">&quot;ERROR: &quot;</span>);
  fprintf(<span class="cConstant">stderr</span>, KNRM);
  va_start(args, format);
  vfprintf(<span class="cConstant">stderr</span>, format, args);
  va_end(args);
}

<span class="cType">void</span> ValLog(<span class="cStorageClass">const</span> <span class="cType">char</span> *format, ...)
{
  <span class="cType">va_list</span> args;
  fprintf(<span class="cConstant">stderr</span>, KBLU);
  fprintf(<span class="cConstant">stderr</span>, <span class="String">&quot;LOG: &quot;</span>);
  fprintf(<span class="cConstant">stderr</span>, KNRM);
  va_start(args, format);
  vfprintf(<span class="cConstant">stderr</span>, format, args);
  va_end(args);
}

<span class="cType">char</span> *ValReadSource(<span class="cStorageClass">const</span> <span class="cType">char</span> *file)
{
  <span class="cType">char</span> *source = <span class="cConstant">NULL</span>;
  <span class="cType">FILE</span> *fp = <span class="cConstant">NULL</span>;
  <span class="cType">long</span> bufsize = -<span class="cNumber">1</span>;
  <span class="cType">size_t</span> newLen;

  <span class="cConditional">if</span> ((fp = fopen(file, <span class="String">&quot;r&quot;</span>)) == <span class="cConstant">NULL</span>) {
    ValErr(<span class="String">&quot;Unable to read file '</span><span class="cFormat">%s</span><span class="String">'.</span><span class="cSpecial">\n</span><span class="String">&quot;</span>, file);
    <span class="Statement">return</span> <span class="cConstant">NULL</span>;
  }

  <span class="cConditional">if</span> (fseek(fp, <span class="cNumber">0L</span>, <span class="cConstant">SEEK_END</span>) != <span class="cNumber">0</span>) {
    ValErr(<span class="String">&quot;File read error '</span><span class="cFormat">%s</span><span class="String">'.</span><span class="cSpecial">\n</span><span class="String">&quot;</span>, file);
    fclose(fp);
    <span class="Statement">return</span> <span class="cConstant">NULL</span>;
  }

  bufsize = ftell(fp);

  <span class="cConditional">if</span> (bufsize == -<span class="cNumber">1</span>) {
    ValErr(<span class="String">&quot;File read error '</span><span class="cFormat">%s</span><span class="String">'.</span><span class="cSpecial">\n</span><span class="String">&quot;</span>, file);
    fclose(fp);
    <span class="Statement">return</span> <span class="cConstant">NULL</span>;
  }

  source = malloc(<span class="cOperator">sizeof</span>(<span class="cType">char</span>) * (bufsize + <span class="cNumber">1</span>));

  <span class="cConditional">if</span> (fseek(fp, <span class="cNumber">0L</span>, <span class="cConstant">SEEK_SET</span>) != <span class="cNumber">0</span>) {
    ValErr(<span class="String">&quot;File read error '</span><span class="cFormat">%s</span><span class="String">'.</span><span class="cSpecial">\n</span><span class="String">&quot;</span>, file);
    fclose(fp);
    <span class="Statement">return</span> <span class="cConstant">NULL</span>;
  }

  newLen = fread(source, <span class="cOperator">sizeof</span>(<span class="cType">char</span>), bufsize, fp);

  <span class="cConditional">if</span> (ferror(fp) != <span class="cNumber">0</span>) {
    ValErr(<span class="String">&quot;File read error '</span><span class="cFormat">%s</span><span class="String">'.</span><span class="cSpecial">\n</span><span class="String">&quot;</span>, file);
    fclose(fp);
    <span class="Statement">return</span> <span class="cConstant">NULL</span>;
  }
  source[newLen++] = <span class="cSpecial">'\0'</span>;

  <span class="Statement">return</span> source;
  <span class="Comment">// free(source);</span>
}

GLFWwindow *CreateGLFWWindow(<span class="cType">int</span> width, <span class="cType">int</span> height)
{
  GLFWwindow* window;

  glfwInit();
  glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, <span class="cNumber">3</span>);
  glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, <span class="cNumber">3</span>);
  glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);

  window = glfwCreateWindow(width, height, <span class="String">&quot;Window&quot;</span>, <span class="cConstant">NULL</span>, <span class="cConstant">NULL</span>);
  <span class="cConditional">if</span> (window == <span class="cConstant">NULL</span>)
  {
    ValErr(<span class="String">&quot;Failed to initialize GLFW window.</span><span class="cSpecial">\n</span><span class="String">&quot;</span>);
    glfwTerminate();
    <span class="Statement">return</span> <span class="cConstant">NULL</span>;
  }

  glfwMakeContextCurrent(window);

  <span class="Statement">return</span> window;
}

<span class="cType">int</span> ValCreateShader(GLenum type, <span class="cStorageClass">const</span> <span class="cType">char</span> *file)
{
  <span class="cType">char</span> *source = ValReadSource(file);
  <span class="cType">int</span> shader;

  <span class="cConditional">if</span> (!(type == GL_VERTEX_SHADER || type == GL_FRAGMENT_SHADER))
  {
    ValErr(<span class="String">&quot;Type can only be 'GL_VERTEX_SHADER' or 'GL_FRAGMENT_SHADER'.</span><span class="cSpecial">\n</span><span class="String">&quot;</span>);
    <span class="Statement">return</span> -<span class="cNumber">1</span>;
  }

  shader = glCreateShader(type);
  glShaderSource(shader, <span class="cNumber">1</span>, (<span class="cStorageClass">const</span> <span class="cType">char</span> **)&amp;source, <span class="cConstant">NULL</span>);
  glCompileShader(shader);

  <span class="cType">int</span> compile_ok;
  <span class="cType">char</span> info[<span class="cNumber">512</span>];
  glGetShaderiv(shader, GL_COMPILE_STATUS, &amp;compile_ok);

  <span class="cConditional">if</span> (!compile_ok)
  {
    glGetShaderInfoLog(shader, <span class="cNumber">512</span>, <span class="cConstant">NULL</span>, info);
    ValErr(<span class="String">&quot;Shader '</span><span class="cFormat">%s</span><span class="String">' compilation failed.</span><span class="cSpecial">\n</span><span class="cFormat">%s</span><span class="cSpecial">\n</span><span class="String">&quot;</span>, file, info);
    <span class="Statement">return</span> -<span class="cNumber">1</span>;
  }

  <span class="Statement">return</span> shader;
}

<span class="cType">int</span> ValCreateProgram(<span class="cType">int</span> vshader, <span class="cType">int</span> fshader)
{
  <span class="cType">int</span> program;

  program = glCreateProgram();
  glAttachShader(program, vshader);
  glAttachShader(program, fshader);
  glLinkProgram(program);

  <span class="cType">int</span> link_ok;
  <span class="cType">char</span> info[<span class="cNumber">512</span>];

  <span class="cConditional">if</span> (!link_ok)
  {
    glGetProgramInfoLog(program, <span class="cNumber">512</span>, <span class="cConstant">NULL</span>, info);
    ValErr(<span class="String">&quot;Program linking failed.</span><span class="cSpecial">\n</span><span class="cFormat">%s</span><span class="cSpecial">\n</span><span class="String">&quot;</span>, info);
    <span class="Statement">return</span> -<span class="cNumber">1</span>;
  }

  glDeleteShader(vshader);
  glDeleteShader(fshader);

  <span class="Statement">return</span> program;
}

<span class="cStorageClass">static</span> <span class="cType">void</span> keyboard(GLFWwindow *window, <span class="cType">int</span> key, <span class="cType">int</span> scancode, <span class="cType">int</span> action, <span class="cType">int</span> mod)
{
  <span class="cStorageClass">const</span> <span class="cType">int</span> ESCAPE = GLFW_KEY_ESCAPE;
  <span class="cStorageClass">const</span> <span class="cType">int</span> PRESS = GLFW_PRESS;

  <span class="cConditional">if</span> (key == ESCAPE &amp;&amp; action == PRESS)
    glfwSetWindowShouldClose(window, <span class="cConstant">true</span>);
}

<span class="cStorageClass">static</span> <span class="cType">void</span> framebuffer(GLFWwindow *window, <span class="cType">int</span> width, <span class="cType">int</span> height)
{
  glViewport(<span class="cNumber">0</span>, <span class="cNumber">0</span>, width, height);
}

GLFWwindow *ValCreateLazyGLFWWindow()
{
  GLFWwindow* window;

  glfwInit();
  glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, <span class="cNumber">3</span>);
  glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, <span class="cNumber">3</span>);
  glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);

  window = glfwCreateWindow(<span class="cNumber">800</span>, <span class="cNumber">600</span>, <span class="String">&quot;Window&quot;</span>, <span class="cConstant">NULL</span>, <span class="cConstant">NULL</span>);
  <span class="cConditional">if</span> (window == <span class="cConstant">NULL</span>)
  {
    ValErr(<span class="String">&quot;Failed to initialize GLFW window.</span><span class="cSpecial">\n</span><span class="String">&quot;</span>);
    glfwTerminate();
    <span class="Statement">return</span> <span class="cConstant">NULL</span>;
  }

  glfwSetKeyCallback(window, keyboard);
  glfwSetFramebufferSizeCallback(window, framebuffer);

  glfwMakeContextCurrent(window);

  <span class="cConditional">if</span> (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress))
  {
    ValErr(<span class="String">&quot;Failed to initialize GLAD.</span><span class="cSpecial">\n</span><span class="String">&quot;</span>);
    <span class="Statement">return</span> <span class="cConstant">NULL</span>;
  }

  <span class="Statement">return</span> window;
}

<span class="cType">int</span> ValLoadProgram(<span class="cStorageClass">const</span> <span class="cType">char</span> *vpath, <span class="cStorageClass">const</span> <span class="cType">char</span> *fpath)
{
  <span class="cType">int</span> program, shader;

  program = glCreateProgram();

  shader = ValCreateShader(GL_VERTEX_SHADER, vpath);
  <span class="cConditional">if</span> (!shader) {
    ValErr(<span class="String">&quot;No Shader.</span><span class="cSpecial">\n</span><span class="String">&quot;</span>);
    <span class="Statement">return</span> -<span class="cNumber">1</span>;
  }
  glAttachShader(program, shader);
  <span class="Comment">//glDeleteShader(shader);</span>

  shader = ValCreateShader(GL_FRAGMENT_SHADER, fpath);
  <span class="cConditional">if</span> (!shader) {
    ValErr(<span class="String">&quot;No Shader.</span><span class="cSpecial">\n</span><span class="String">&quot;</span>);
    <span class="Statement">return</span> -<span class="cNumber">1</span>;
  }
  glAttachShader(program, shader);
  <span class="Comment">//glDeleteShader(shader);</span>

  glLinkProgram(program);

  <span class="cType">int</span> link_ok = <span class="cConstant">true</span>;
  <span class="cType">char</span> info[<span class="cNumber">512</span>];

  <span class="cConditional">if</span> (!link_ok)
  {
    glGetProgramInfoLog(program, <span class="cNumber">512</span>, <span class="cConstant">NULL</span>, info);
    ValErr(<span class="String">&quot;Program linking failed.</span><span class="cSpecial">\n</span><span class="cFormat">%s</span><span class="cSpecial">\n</span><span class="String">&quot;</span>, info);
    <span class="Statement">return</span> -<span class="cNumber">1</span>;
  }

  <span class="Statement">return</span> program;
}

<span class="cType">int</span> ValGetUniform(<span class="cType">int</span> program, <span class="cStorageClass">const</span> <span class="cType">char</span> *name)
{
  <span class="cType">int</span> uniform = glGetUniformLocation(program, name);

  <span class="cConditional">if</span> (uniform == -<span class="cNumber">1</span>)
  {
    ValErr(<span class="String">&quot;Unable to get uniform '</span><span class="cFormat">%s</span><span class="String">'.</span><span class="cSpecial">\n</span><span class="String">&quot;</span>, name);
  }

  <span class="Statement">return</span> uniform;
}
</pre>
</body>
</html>
<!-- vim: set foldmethod=manual : -->
